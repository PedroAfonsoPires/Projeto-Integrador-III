Index: analisador_lexico.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import ply.lex as lex\r\n\r\n#Lista de tokens\r\ntokens = (\r\n    'IF', 'ELSE', 'SWITCH', 'WHILE', 'FOR', 'DO_WHILE', 'ASSIGN',\r\n    'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'MOD', 'POW', 'LT', 'GT',\r\n    'LE', 'GE', 'EQ', 'NE', 'COMMENT', 'ID', 'LPAREN', 'RPAREN',\r\n    'LBRACE', 'RBRACE', 'INCLUDE', 'SEMICOLON', 'COMMA', 'LBRACK', 'RBRACK',\r\n    'STRING', 'NUMBER', 'FLOAT', 'AMPERSAND','AND', 'PIPE', 'CHARACTER', 'OR',\r\n    'TYPEDEF', 'DOT', 'COLON',\r\n)\r\n\r\n# Regra para o caractere ':'\r\nt_COLON = r':'\r\n\r\n#Regra para o ponto como operador de acesso\r\nt_DOT = r'\\.'\r\n\r\n#Regra para diretivas de pré-processamento\r\nt_INCLUDE = r'\\#\\s*include\\s*<([a-zA-Z0-9_.]+)>'\r\n\r\n#Regras para tokens de comandos condicionais\r\nt_IF     = r'if'\r\nt_ELSE   = r'else'\r\nt_SWITCH = r'switch'\r\n\r\n#Regras para tokens de comandos de laço\r\nt_WHILE    = r'while'\r\nt_FOR      = r'for'\r\nt_DO_WHILE = r'do_while'\r\n\r\n#Regra para operador de atribuição\r\nt_ASSIGN = r'='\r\nt_PLUS   = r'\\+'\r\nt_MINUS  = r'-'\r\nt_TIMES  = r'\\*'\r\nt_DIVIDE = r'/'\r\nt_MOD    = r'%'\r\nt_POW    = r'\\^'\r\n\r\n#Regras para operadores de comparação\r\nt_LT = r'<'\r\nt_GT = r'>'\r\nt_LE = r'<='\r\nt_GE = r'>='\r\nt_EQ = r'=='\r\nt_NE = r'!='\r\n\r\n#Regra para comentários (de linha e bloco)\r\nt_COMMENT = r'//.*|/\\*.*?\\*/'\r\n\r\n#Regra para identificadores\r\nt_ID = r'[a-zA-Z_][a-zA-Z0-9_]*'\r\n\r\n# Regras para tokens de tipo\r\nt_TYPEDEF = r'typedef'\r\n\r\n#Regras para parênteses e chaves\r\nt_LPAREN = r'\\('\r\nt_RPAREN = r'\\)'\r\nt_LBRACE = r'\\{'\r\nt_RBRACE = r'\\}'\r\n\r\n#Regras para colchetes\r\nt_LBRACK = r'\\['\r\nt_RBRACK = r'\\]'\r\n\r\n#Regra para vírgula\r\nt_COMMA = r','\r\n\r\n#Regra para ponto e vírgula\r\nt_SEMICOLON = r';'\r\n\r\n#Regra para strings\r\nt_STRING = r'\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"'\r\n\r\n#Regra para números inteiros\r\nt_NUMBER = r'\\d+'\r\n\r\n#Regra para números reais\r\nt_FLOAT = r'\\d+\\.\\d+'\r\n\r\n#Ignorar espaços em branco\r\nt_ignore = r' \\t'\r\n\r\n# Regra para o operador '&'\r\nt_AMPERSAND = r'&'\r\nt_AND = r'&&'\r\n\r\n# Regra para o operador '|'\r\nt_PIPE = r'\\|'\r\nt_OR = r'\\|\\|'\r\n\r\n# Regra para caracteres\r\nt_CHARACTER = r\"'([^'\\\\]*(\\\\.[^'\\\\]*)*)'\"\r\n\r\n#Contador de linha\r\ndef t_newline(t):\r\n    r'\\n+'\r\n    t.lexer.lineno += len(t.value)\r\n\r\n#Erros de caracteres ilegais\r\ndef t_error(t):\r\n    print(f\"Caractere ilegal '{t.value[0]}' na linha {t.lexer.lineno}\")\r\n    t.lexer.skip(1)\r\n\r\n#Tabela de símbolos\r\nsymbol_table = {}\r\n\r\n#Criar o analisador léxico\r\nlexer = lex.lex()\r\n\r\n#Função para processar o código de entrada\r\ndef process_code(data):\r\n    lexer.input(data)\r\n\r\n    while True:\r\n        tok = lexer.token()\r\n        if not tok:\r\n            break\r\n        #Adiciona à tabela de símbolos\r\n        if tok.type not in symbol_table:\r\n            symbol_table[tok.type] = []\r\n        symbol_table[tok.type].append((tok.value, tok.lineno))\r\n        print(f\"Token: {tok.type}, Valor: {tok.value}, Linha: {tok.lineno}\")\r\n\r\n#Código de exemplo em C\r\nname = input();\r\nwith open(name, 'r', encoding=\"utf-8\") as file_:\r\n    c_code = file_.read();\r\n\r\n#Processar o código de entrada\r\nprocess_code(c_code)\r\n\r\n#Exibir a tabela de símbolos\r\nprint(\"\\nTabela de Símbolos:\")\r\nfor token_type, occurrences in symbol_table.items():\r\n    print(f\"{token_type}: {occurrences}\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/analisador_lexico.py b/analisador_lexico.py
--- a/analisador_lexico.py	(revision 0a1fc91cfe26ec967889b898af0bb29e1770b976)
+++ b/analisador_lexico.py	(date 1732304185192)
@@ -1,138 +1,170 @@
 import ply.lex as lex
 
-#Lista de tokens
+# Lista de tokens
 tokens = (
-    'IF', 'ELSE', 'SWITCH', 'WHILE', 'FOR', 'DO_WHILE', 'ASSIGN',
-    'PLUS', 'MINUS', 'TIMES', 'DIVIDE', 'MOD', 'POW', 'LT', 'GT',
-    'LE', 'GE', 'EQ', 'NE', 'COMMENT', 'ID', 'LPAREN', 'RPAREN',
-    'LBRACE', 'RBRACE', 'INCLUDE', 'SEMICOLON', 'COMMA', 'LBRACK', 'RBRACK',
-    'STRING', 'NUMBER', 'FLOAT', 'AMPERSAND','AND', 'PIPE', 'CHARACTER', 'OR',
-    'TYPEDEF', 'DOT', 'COLON',
+    'IF',
+    'ELSE',
+    'SWITCH',
+    'WHILE',
+    'FOR',
+    'DO',
+    'ASSIGN',
+    'PLUS',
+    'MINUS',
+    'TIMES',
+    'DIVIDE',
+    'MOD',
+    'POW',
+    'LT',
+    'GT',
+    'LE',
+    'GE',
+    'EQ',
+    'NE',
+    'COMMENT',
+    'LPAREN',
+    'RPAREN',
+    'LBRACE',
+    'RBRACE',
+    'SEMICOLON',
+    'COMMA',
+    'LBRACK',
+    'RBRACK',
+    'STRING',
+    'NUMBER',
+    'AMPERSAND',
+    'AND',
+    'PIPE',
+    'CHARACTER',
+    'OR',
+    'TYPEDEF',
+    'DOT',
+    'COLON',
+    'HASH',
+    'INT',
+    'FLOAT',
+    'CHAR',
+    'DOUBLE',
+    'VOID',
+    'POINTER',
+    'TYPE',
+    'ID',
+    'PLUS_PLUS',
+    'MINUS_MINUS',
+    'PLUS_EQUAL',
+    'MINUS_EQUAL',
+    'RETURN',
 )
 
-# Regra para o caractere ':'
+# Regras para tokens
+t_COMMENT = r'//.*|/\*.*?\*/'
 t_COLON = r':'
-
-#Regra para o ponto como operador de acesso
+t_HASH = r'\#.*'
 t_DOT = r'\.'
-
-#Regra para diretivas de pré-processamento
-t_INCLUDE = r'\#\s*include\s*<([a-zA-Z0-9_.]+)>'
-
-#Regras para tokens de comandos condicionais
-t_IF     = r'if'
-t_ELSE   = r'else'
-t_SWITCH = r'switch'
-
-#Regras para tokens de comandos de laço
-t_WHILE    = r'while'
-t_FOR      = r'for'
-t_DO_WHILE = r'do_while'
-
-#Regra para operador de atribuição
+#t_IF = r'if'
+#t_ELSE = r'else'
+#t_SWITCH = r'switch'
+#t_WHILE = r'while'
+#t_FOR = r'for'
+#t_DO_WHILE = r'do_while'
 t_ASSIGN = r'='
-t_PLUS   = r'\+'
-t_MINUS  = r'-'
-t_TIMES  = r'\*'
+t_PLUS = r'\+'
+t_MINUS = r'-'
+t_TIMES = r'\*'
 t_DIVIDE = r'/'
-t_MOD    = r'%'
-t_POW    = r'\^'
-
-#Regras para operadores de comparação
+t_MOD = r'%'
+t_POW = r'\^'
 t_LT = r'<'
 t_GT = r'>'
 t_LE = r'<='
 t_GE = r'>='
 t_EQ = r'=='
 t_NE = r'!='
-
-#Regra para comentários (de linha e bloco)
-t_COMMENT = r'//.*|/\*.*?\*/'
-
-#Regra para identificadores
-t_ID = r'[a-zA-Z_][a-zA-Z0-9_]*'
-
-# Regras para tokens de tipo
 t_TYPEDEF = r'typedef'
-
-#Regras para parênteses e chaves
 t_LPAREN = r'\('
 t_RPAREN = r'\)'
 t_LBRACE = r'\{'
 t_RBRACE = r'\}'
-
-#Regras para colchetes
 t_LBRACK = r'\['
 t_RBRACK = r'\]'
-
-#Regra para vírgula
 t_COMMA = r','
-
-#Regra para ponto e vírgula
 t_SEMICOLON = r';'
-
-#Regra para strings
 t_STRING = r'"([^"\\]*(\\.[^"\\]*)*)"'
-
-#Regra para números inteiros
 t_NUMBER = r'\d+'
-
-#Regra para números reais
-t_FLOAT = r'\d+\.\d+'
-
-#Ignorar espaços em branco
-t_ignore = r' \t'
-
-# Regra para o operador '&'
 t_AMPERSAND = r'&'
 t_AND = r'&&'
-
-# Regra para o operador '|'
 t_PIPE = r'\|'
 t_OR = r'\|\|'
-
-# Regra para caracteres
 t_CHARACTER = r"'([^'\\]*(\\.[^'\\]*)*)'"
-
-#Contador de linha
+t_INT = r'int'
+t_FLOAT = r'float'
+t_VOID = r'void'
+t_CHAR = r'char'
+t_DOUBLE = r'double'
+t_POINTER = r'\*'
+t_TYPE = r'int|float|void|char|double'
+t_PLUS_PLUS = r'\+\+'
+t_MINUS_MINUS = r'--'
+t_PLUS_EQUAL = r'\+='
+t_MINUS_EQUAL = r'-='
+#t_RETURN = r'return'
+# Contador de linha
 def t_newline(t):
     r'\n+'
     t.lexer.lineno += len(t.value)
 
-#Erros de caracteres ilegais
+
+# Ignorar espaços em branco e tabulações
+t_ignore = r' \t'
+
+
+# Regra para identificadores
+t_ID = r'[a-zA-Z_][a-zA-Z0-9_]*'
+
+def t_RETURN(t):
+    r'return'
+    return t
+
+def t_IF(t):
+    r'if'
+    return t
+
+def t_ELSE(t):
+    r'else'
+    return t
+
+def t_SWITCH(t):
+    r'switch'
+    return t
+
+def t_FOR(t):
+    r'for'
+    return t
+
+def t_WHILE(t):
+    r'while'
+    return t
+
+def t_DO(t):
+    r'do'
+    return t
+
+
+# Erros de caracteres ilegais
 def t_error(t):
     print(f"Caractere ilegal '{t.value[0]}' na linha {t.lexer.lineno}")
     t.lexer.skip(1)
 
-#Tabela de símbolos
-symbol_table = {}
-
-#Criar o analisador léxico
+# Criar o analisador léxico
 lexer = lex.lex()
 
-#Função para processar o código de entrada
-def process_code(data):
+# Função para processar o código de entrada
+def process_code(data, k):
     lexer.input(data)
-
-    while True:
-        tok = lexer.token()
-        if not tok:
-            break
-        #Adiciona à tabela de símbolos
-        if tok.type not in symbol_table:
-            symbol_table[tok.type] = []
-        symbol_table[tok.type].append((tok.value, tok.lineno))
-        print(f"Token: {tok.type}, Valor: {tok.value}, Linha: {tok.lineno}")
-
-#Código de exemplo em C
-name = input();
-with open(name, 'r', encoding="utf-8") as file_:
-    c_code = file_.read();
-
-#Processar o código de entrada
-process_code(c_code)
-
-#Exibir a tabela de símbolos
-print("\nTabela de Símbolos:")
-for token_type, occurrences in symbol_table.items():
-    print(f"{token_type}: {occurrences}")
\ No newline at end of file
+    if k != 0:
+        while True:
+            tok = lexer.token()
+            if not tok:
+                break
+            print(
+                f"Token: {tok.type}, Valor: {tok.value}, Linha: {tok.lineno}")
Index: test1.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Definindo um enum para o status do estudante\r\nenum StatusEstudante {\r\n    MATRICULADO,\r\n    CANCELADO,\r\n    FORMADO\r\n};\r\n\r\n// Definindo uma struct para representar um estudante sem typedef\r\nstruct EstudanteSemTypedef {\r\n    char nome[50];\r\n    int idade;\r\n    enum StatusEstudante status;\r\n};\r\n\r\n// Definindo uma struct para representar um estudante com typedef\r\ntypedef struct {\r\n    char nome[50];\r\n    int idade;\r\n    enum StatusEstudante status;\r\n} EstudanteComTypedef;\r\n\r\n// Função para exibir informações do estudante sem typedef\r\nvoid exibirEstudanteSemTypedef(struct EstudanteSemTypedef e) {\r\n    printf(\"Nome: %s\\n\", e.nome);\r\n    printf(\"Idade: %d\\n\", e.idade);\r\n    printf(\"Status: \");\r\n    switch (e.status) {\r\n        case MATRICULADO: printf(\"MATRICULADO\\n\"); break;\r\n        case CANCELADO: printf(\"CANCELADO\\n\"); break;\r\n        case FORMADO: printf(\"FORMADO\\n\"); break;\r\n    }\r\n}\r\n\r\n// Função para exibir informações do estudante com typedef\r\nvoid exibirEstudanteComTypedef(EstudanteComTypedef e) {\r\n    printf(\"Nome: %s\\n\", e.nome);\r\n    printf(\"Idade: %d\\n\", e.idade);\r\n    printf(\"Status: \");\r\n    switch (e.status) {\r\n        case MATRICULADO: printf(\"MATRICULADO\\n\"); break;\r\n        case CANCELADO: printf(\"CANCELADO\\n\"); break;\r\n        case FORMADO: printf(\"FORMADO\\n\"); break;\r\n    }\r\n}\r\n\r\nint main() {\r\n    // Criando e inicializando um estudante sem typedef\r\n    struct EstudanteSemTypedef estudante1;\r\n    strcpy(estudante1.nome, \"Maria Silva\");\r\n    estudante1.idade = 20;\r\n    estudante1.status = MATRICULADO;\r\n\r\n    // Exibindo informações do estudante sem typedef\r\n    printf(\"Informações do Estudante (sem typedef):\\n\");\r\n    exibirEstudanteSemTypedef(estudante1);\r\n\r\n    // Criando e inicializando um estudante com typedef\r\n    EstudanteComTypedef estudante2;\r\n    strcpy(estudante2.nome, \"João Souza\");\r\n    estudante2.idade = 22;\r\n    estudante2.status = FORMADO;\r\n\r\n    // Exibindo informações do estudante com typedef\r\n    printf(\"\\nInformações do Estudante (com typedef):\\n\");\r\n    exibirEstudanteComTypedef(estudante2);\r\n\r\n    return 0;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test1.c b/test1.c
--- a/test1.c	(revision 0a1fc91cfe26ec967889b898af0bb29e1770b976)
+++ b/test1.c	(date 1727966824043)
@@ -29,7 +29,7 @@
     printf("Status: ");
     switch (e.status) {
         case MATRICULADO: printf("MATRICULADO\n"); break;
-        case CANCELADO: printf("CANCELADO\n"); break;
+        case CANCELADO: printf("CANCELADO\n                                                     "); break;
         case FORMADO: printf("FORMADO\n"); break;
     }
 }
Index: quick_sort.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>⍩湣汵摥‼獴摩漮栾ഊഊ⼯⁆畮쎧쎣漠灡牡⁴牯捡爠摯楳\u2065汥浥湴潳ഊ癯楤\u2073睡瀨楮琪\u2061Ⱐ楮琪\u2062⤠笍ਠ†\u2069湴⁴敭瀠㴠⩡㬍ਠ†\u202A愠㴠⩢㬍ਠ†\u202A戠㴠瑥浰㬍\u0A7Dഊഊ⼯⁐慲瑩捩潮愠漠慲牡礠攠牥瑯牮愠漠쎭湤楣攠摯⁰楶쎴ഊ楮琠灡牴楴楯渨楮琠慲牛崬\u2069湴\u206C潷Ⱐ楮琠桩杨⤠笍ਠ†\u2069湴⁰楶潴‽\u2061牲孨楧桝㬠⼯⁅獣潬桥\u206F\u20C3멬瑩浯\u2065汥浥湴漠捯浯⁰楶쎴ഊ††楮琠椠㴠⡬潷\u202D‱⤻ ⼠쎍湤楣攠摯\u206D敮潲\u2065汥浥湴漍\u0A0Dਠ†\u2066潲\u2028楮琠樠㴠汯眻\u206A‼\u2068楧栻\u206A⬫⤠笍ਠ††† ⼠卥\u206F\u2065汥浥湴漠慴畡氠쎩\u206D敮潲\u206F甠楧畡氠慯⁰楶쎴ഊ††††楦\u2028慲牛橝‼㴠灩癯琩⁻ഊ††††††椫⬻ ⼠䥮捲敭敮瑡\u206F\u20C3굮摩捥\u2064漠浥湯爠敬敭敮瑯ഊ††††††獷慰⠦慲牛楝Ⱐ♡牲孪崩㬍ਠ†††⁽ഊ††納ਠ†\u2073睡瀨♡牲孩\u202B‱崬…慲牛桩杨崩㬠⼯⁃潬潣愠漠灩盃될湡⁰潳槃ꟃꍯ\u2063潲牥瑡ഊ††牥瑵牮\u2028椠⬠ㄩ㬍\u0A7Dഊഊ⼯⁆畮쎧쎣漠灲楮捩灡氠摯⁑畩捫獯牴ഊ癯楤ⁱ畩捫獯牴⡩湴\u2061牲孝Ⱐ楮琠汯眬\u2069湴\u2068楧栩⁻ഊ††楦\u2028汯眠㰠桩杨⤠笍ਠ††† ⼠偡牴楣楯湡\u206F\u2061牲慹\u2065\u206F扴쎩洠漠쎭湤楣攠摯⁰楶쎴ഊ††††楮琠灩‽⁰慲瑩瑩潮⡡牲Ⱐ汯眬\u2068楧栩㬍\u0A0Dਠ††† ⼠佲摥湡\u2072散畲獩癡浥湴攠慳\u2064畡猠浥瑡摥猍ਠ†††ⁱ畩捫獯牴⡡牲Ⱐ汯眬⁰椠ⴠㄩ㬍ਠ†††ⁱ畩捫獯牴⡡牲Ⱐ灩\u202B‱Ⱐ桩杨⤻ഊ††納\u0A7Dഊഊ⼯⁆畮쎧쎣漠灡牡\u2069浰物浩爠漠慲牡礍੶潩搠灲楮瑁牲慹⡩湴\u2061牲孝Ⱐ楮琠獩穥⤠笍ਠ†\u2066潲\u2028楮琠椠㴠〻\u2069‼\u2073楺攻\u2069⬫⤠笍ਠ†††⁰物湴昨∥搠∬\u2061牲孩崩㬍ਠ†⁽ഊ††灲楮瑦⠢屮∩㬍\u0A7Dഊഊ⼯⁆畮쎧쎣漠灲楮捩灡氍੩湴\u206D慩渨⤠笍ਠ†\u2069湴\u2061牲孝‽⁻\u3130Ⱐ㜬‸Ⱐ㤬‱Ⱐ㕽㬍ਠ†\u2069湴\u206E‽\u2073楺敯昨慲爩 \u2073楺敯昨慲牛そ⤻ഊഊ††灲楮瑦⠢䅲牡礠潲楧楮慬㨠∩㬍ਠ†⁰物湴䅲牡礨慲爬\u206E⤻ഊഊ††煵楣歳潲琨慲爬‰Ⱐ渠ⴠㄩ㬍\u0A0Dਠ†⁰物湴昨≁牲慹\u206F牤敮慤漺•⤻ഊ††灲楮瑁牲慹⡡牲Ⱐ温㬍ਠ†\u2072整畲渠〻ഊ�
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-16
===================================================================
diff --git a/quick_sort.c b/quick_sort.c
--- a/quick_sort.c	(revision 0a1fc91cfe26ec967889b898af0bb29e1770b976)
+++ b/quick_sort.c	(date 1732309134095)
@@ -1,1 +1,1 @@
-⍩湣汵摥‼獴摩漮栾ഊഊ⼯⁆畮쎧쎣漠灡牡⁴牯捡爠摯楳⁥汥浥湴潳ഊ癯楤⁳睡瀨楮琪⁡Ⱐ楮琪⁢⤠笍ਠ†⁩湴⁴敭瀠㴠⩡㬍ਠ†‪愠㴠⩢㬍ਠ†‪戠㴠瑥浰㬍੽ഊഊ⼯⁐慲瑩捩潮愠漠慲牡礠攠牥瑯牮愠漠쎭湤楣攠摯⁰楶쎴ഊ楮琠灡牴楴楯渨楮琠慲牛崬⁩湴⁬潷Ⱐ楮琠桩杨⤠笍ਠ†⁩湴⁰楶潴‽⁡牲孨楧桝㬠⼯⁅獣潬桥⁯⃃멬瑩浯⁥汥浥湴漠捯浯⁰楶쎴ഊ††楮琠椠㴠⡬潷‭‱⤻ ⼠쎍湤楣攠摯⁭敮潲⁥汥浥湴漍਍ਠ†⁦潲 楮琠樠㴠汯眻⁪‼⁨楧栻⁪⬫⤠笍ਠ††† ⼠卥⁯⁥汥浥湴漠慴畡氠쎩⁭敮潲⁯甠楧畡氠慯⁰楶쎴ഊ††††楦 慲牛橝‼㴠灩癯琩⁻ഊ††††††椫⬻ ⼠䥮捲敭敮瑡⁯⃃굮摩捥⁤漠浥湯爠敬敭敮瑯ഊ††††††獷慰⠦慲牛楝Ⱐ♡牲孪崩㬍ਠ†††⁽ഊ††納ਠ†⁳睡瀨♡牲孩‫‱崬…慲牛桩杨崩㬠⼯⁃潬潣愠漠灩盃될湡⁰潳槃ꟃꍯ⁣潲牥瑡ഊ††牥瑵牮 椠⬠ㄩ㬍੽ഊഊ⼯⁆畮쎧쎣漠灲楮捩灡氠摯⁑畩捫獯牴ഊ癯楤ⁱ畩捫獯牴⡩湴⁡牲孝Ⱐ楮琠汯眬⁩湴⁨楧栩⁻ഊ††楦 汯眠㰠桩杨⤠笍ਠ††† ⼠偡牴楣楯湡⁯⁡牲慹⁥⁯扴쎩洠漠쎭湤楣攠摯⁰楶쎴ഊ††††楮琠灩‽⁰慲瑩瑩潮⡡牲Ⱐ汯眬⁨楧栩㬍਍ਠ††† ⼠佲摥湡⁲散畲獩癡浥湴攠慳⁤畡猠浥瑡摥猍ਠ†††ⁱ畩捫獯牴⡡牲Ⱐ汯眬⁰椠ⴠㄩ㬍ਠ†††ⁱ畩捫獯牴⡡牲Ⱐ灩‫‱Ⱐ桩杨⤻ഊ††納੽ഊഊ⼯⁆畮쎧쎣漠灡牡⁩浰物浩爠漠慲牡礍੶潩搠灲楮瑁牲慹⡩湴⁡牲孝Ⱐ楮琠獩穥⤠笍ਠ†⁦潲 楮琠椠㴠〻⁩‼⁳楺攻⁩⬫⤠笍ਠ†††⁰物湴昨∥搠∬⁡牲孩崩㬍ਠ†⁽ഊ††灲楮瑦⠢屮∩㬍੽ഊഊ⼯⁆畮쎧쎣漠灲楮捩灡氍੩湴⁭慩渨⤠笍ਠ†⁩湴⁡牲孝‽⁻㄰Ⱐ㜬‸Ⱐ㤬‱Ⱐ㕽㬍ਠ†⁩湴⁮‽⁳楺敯昨慲爩 ⁳楺敯昨慲牛そ⤻ഊഊ††灲楮瑦⠢䅲牡礠潲楧楮慬㨠∩㬍ਠ†⁰物湴䅲牡礨慲爬⁮⤻ഊഊ††煵楣歳潲琨慲爬‰Ⱐ渠ⴠㄩ㬍਍ਠ†⁰物湴昨≁牲慹⁯牤敮慤漺•⤻ഊ††灲楮瑁牲慹⡡牲Ⱐ温㬍ਠ†⁲整畲渠〻ഊ�
\ No newline at end of file
+ഊ⍩湣汵摥‼獴摩漮栾ഊഊ⼯⁆畮漠灡牡⁴牯捡爠摯楳⁥汥浥湴潳ഊ癯楤⁳睡瀨楮琪⁡Ⱐ楮琪⁢⤠笍ਠ†⁩湴⁴敭瀠㴠⩡㬍ਠ†‪愠㴠⩢㬍ਠ†‪戠㴠瑥浰㬍੽ഊഊ⼯⁐慲瑩捩潮愠漠慲牡礠攠牥瑯牮愠漠摩捥⁤漠灩直ഊ楮琠灡牴楴楯渨楮琠慲牛崬⁩湴⁬潷Ⱐ楮琠桩杨⤠笍ਠ†⁩湴⁰楶潴‽⁡牲孨楧桝㬠⼯⁅獣潬桥⁯⃺汴業漠敬敭敮瑯⁣潭漠灩直ഊ††楮琠椠㴠⡬潷‭‱⤻ ⼠쵮摩捥⁤漠浥湯爠敬敭敮瑯ഊഊ††景爠⡩湴⁪‽⁬潷㬠樠㰠桩杨㬠樫⬩⁻ഊ††††⼯⁓攠漠敬敭敮瑯⁡瑵慬⃩⁭敮潲⁯甠楧畡氠慯⁰楶ਠ†††⁩映⡡牲孪崠㰽⁰楶潴⤠笍ਠ†††††⁩⬫㬠⼯⁉湣牥浥湴愠漠摩捥⁤漠浥湯爠敬敭敮瑯ഊ††††††獷慰⠦慲牛楝Ⱐ♡牲孪崩㬍ਠ†††⁽ഊ††納ਠ†⁳睡瀨♡牲孩‫‱崬…慲牛桩杨崩㬠⼯⁃潬潣愠漠灩直⁮愠灯獩漠捯牲整愍ਠ†⁲整畲渠⡩‫‱⤻ഊ納਍ਯ⼠䙵滧⁰物湣楰慬⁤漠兵楣歳潲琍੶潩搠煵楣歳潲琨楮琠慲牛崬⁩湴⁬潷Ⱐ楮琠桩杨⤠笍ਠ†⁩映⡬潷‼⁨楧栩⁻ഊ††††⼯⁐慲瑩捩潮愠漠慲牡礠攠潢瓩洠漠摩捥⁤漠灩直ഊ††††楮琠灩‽⁰慲瑩瑩潮⡡牲Ⱐ汯眬⁨楧栩㬍਍ਠ††† ⼠佲摥湡⁲散畲獩癡浥湴攠慳⁤畡猠浥瑡摥猍ਠ†††ⁱ畩捫獯牴⡡牲Ⱐ汯眬⁰椠ⴠㄩ㬍ਠ†††ⁱ畩捫獯牴⡡牲Ⱐ灩‫‱Ⱐ桩杨⤻ഊ††納੽ഊഊ⼯⁆畮漠灡牡⁩浰物浩爠漠慲牡礍੶潩搠灲楮瑁牲慹⡩湴⁡牲孝Ⱐ楮琠獩穥⤠笍ਠ†⁦潲 楮琠椠㴠〻⁩‼⁳楺攻⁩⬫⤠笍ਠ†††⁰物湴昨∥搠∬⁡牲孩崩㬍ਠ†⁽ഊ††灲楮瑦⠢屮∩㬍੽ഊഊ⼯⁆畮漠灲楮捩灡氍੩湴⁭慩渨⤠笍ਠ†⁩湴⁡牲孝‽⁻㄰Ⱐ㜬‸Ⱐ㤬‱Ⱐ㕽㬍ਠ†⁩湴⁮‽⁳楺敯昨慲爩 ⁳楺敯昨慲牛そ⤻ഊഊ††灲楮瑦⠢䅲牡礠潲楧楮慬㨠∩㬍ਠ†⁰物湴䅲牡礨慲爬⁮⤻ഊഊ††煵楣歳潲琨慲爬‰Ⱐ渠ⴠㄩ㬍਍ਠ†⁰物湴昨≁牲慹⁯牤敮慤漺•⤻ഊ††灲楮瑁牲慹⡡牲Ⱐ温㬍ਠ†⁲整畲渠〻ഊ納�
\ No newline at end of file
Index: .idea/parser.out
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/parser.out b/.idea/parser.out
new file mode 100644
--- /dev/null	(date 1731111492181)
+++ b/.idea/parser.out	(date 1731111492181)
@@ -0,0 +1,1016 @@
+Created by PLY version 3.11 (http://www.dabeaz.com/ply)
+
+Unused terminals:
+
+    AMPERSAND
+    AND
+    CHARACTER
+    COLON
+    COMMA
+    COMMENT
+    DOT
+    DO_WHILE
+    EQ
+    FLOAT
+    GE
+    GT
+    HASH
+    LBRACK
+    LE
+    LT
+    MOD
+    NE
+    OR
+    PIPE
+    POW
+    RBRACK
+    STRING
+    SWITCH
+    TYPEDEF
+
+Grammar
+
+Rule 0     S' -> program
+Rule 1     program -> statement_list
+Rule 2     statement_list -> statement
+Rule 3     statement_list -> statement_list statement
+Rule 4     statement -> expression_statement
+Rule 5     statement -> if_statement
+Rule 6     statement -> while_statement
+Rule 7     statement -> for_statement
+Rule 8     statement -> block
+Rule 9     expression_statement -> expression SEMICOLON
+Rule 10    if_statement -> IF LPAREN expression RPAREN statement ELSE statement
+Rule 11    if_statement -> IF LPAREN expression RPAREN statement
+Rule 12    while_statement -> WHILE LPAREN expression RPAREN statement
+Rule 13    for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement
+Rule 14    block -> LBRACE statement_list RBRACE
+Rule 15    expression -> ID ASSIGN expression
+Rule 16    expression -> expression PLUS expression
+Rule 17    expression -> expression MINUS expression
+Rule 18    expression -> expression TIMES expression
+Rule 19    expression -> expression DIVIDE expression
+Rule 20    expression -> NUMBER
+Rule 21    expression -> ID
+
+Terminals, with rules where they appear
+
+AMPERSAND            : 
+AND                  : 
+ASSIGN               : 15
+CHARACTER            : 
+COLON                : 
+COMMA                : 
+COMMENT              : 
+DIVIDE               : 19
+DOT                  : 
+DO_WHILE             : 
+ELSE                 : 10
+EQ                   : 
+FLOAT                : 
+FOR                  : 13
+GE                   : 
+GT                   : 
+HASH                 : 
+ID                   : 15 21
+IF                   : 10 11
+LBRACE               : 14
+LBRACK               : 
+LE                   : 
+LPAREN               : 10 11 12 13
+LT                   : 
+MINUS                : 17
+MOD                  : 
+NE                   : 
+NUMBER               : 20
+OR                   : 
+PIPE                 : 
+PLUS                 : 16
+POW                  : 
+RBRACE               : 14
+RBRACK               : 
+RPAREN               : 10 11 12 13
+SEMICOLON            : 9
+STRING               : 
+SWITCH               : 
+TIMES                : 18
+TYPEDEF              : 
+WHILE                : 12
+error                : 
+
+Nonterminals, with rules where they appear
+
+block                : 8
+expression           : 9 10 11 12 13 15 16 16 17 17 18 18 19 19
+expression_statement : 4 13 13
+for_statement        : 7
+if_statement         : 5
+program              : 0
+statement            : 2 3 10 10 11 12 13
+statement_list       : 1 3 14
+while_statement      : 6
+
+Parsing method: LALR
+
+state 0
+
+    (0) S' -> . program
+    (1) program -> . statement_list
+    (2) statement_list -> . statement
+    (3) statement_list -> . statement_list statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    program                        shift and go to state 1
+    statement_list                 shift and go to state 2
+    statement                      shift and go to state 3
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+    expression                     shift and go to state 9
+
+state 1
+
+    (0) S' -> program .
+
+
+
+state 2
+
+    (1) program -> statement_list .
+    (3) statement_list -> statement_list . statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    $end            reduce using rule 1 (program -> statement_list .)
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    statement                      shift and go to state 16
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+    expression                     shift and go to state 9
+
+state 3
+
+    (2) statement_list -> statement .
+
+    IF              reduce using rule 2 (statement_list -> statement .)
+    WHILE           reduce using rule 2 (statement_list -> statement .)
+    FOR             reduce using rule 2 (statement_list -> statement .)
+    LBRACE          reduce using rule 2 (statement_list -> statement .)
+    ID              reduce using rule 2 (statement_list -> statement .)
+    NUMBER          reduce using rule 2 (statement_list -> statement .)
+    $end            reduce using rule 2 (statement_list -> statement .)
+    RBRACE          reduce using rule 2 (statement_list -> statement .)
+
+
+state 4
+
+    (4) statement -> expression_statement .
+
+    IF              reduce using rule 4 (statement -> expression_statement .)
+    WHILE           reduce using rule 4 (statement -> expression_statement .)
+    FOR             reduce using rule 4 (statement -> expression_statement .)
+    LBRACE          reduce using rule 4 (statement -> expression_statement .)
+    ID              reduce using rule 4 (statement -> expression_statement .)
+    NUMBER          reduce using rule 4 (statement -> expression_statement .)
+    $end            reduce using rule 4 (statement -> expression_statement .)
+    RBRACE          reduce using rule 4 (statement -> expression_statement .)
+    ELSE            reduce using rule 4 (statement -> expression_statement .)
+
+
+state 5
+
+    (5) statement -> if_statement .
+
+    IF              reduce using rule 5 (statement -> if_statement .)
+    WHILE           reduce using rule 5 (statement -> if_statement .)
+    FOR             reduce using rule 5 (statement -> if_statement .)
+    LBRACE          reduce using rule 5 (statement -> if_statement .)
+    ID              reduce using rule 5 (statement -> if_statement .)
+    NUMBER          reduce using rule 5 (statement -> if_statement .)
+    $end            reduce using rule 5 (statement -> if_statement .)
+    RBRACE          reduce using rule 5 (statement -> if_statement .)
+    ELSE            reduce using rule 5 (statement -> if_statement .)
+
+
+state 6
+
+    (6) statement -> while_statement .
+
+    IF              reduce using rule 6 (statement -> while_statement .)
+    WHILE           reduce using rule 6 (statement -> while_statement .)
+    FOR             reduce using rule 6 (statement -> while_statement .)
+    LBRACE          reduce using rule 6 (statement -> while_statement .)
+    ID              reduce using rule 6 (statement -> while_statement .)
+    NUMBER          reduce using rule 6 (statement -> while_statement .)
+    $end            reduce using rule 6 (statement -> while_statement .)
+    RBRACE          reduce using rule 6 (statement -> while_statement .)
+    ELSE            reduce using rule 6 (statement -> while_statement .)
+
+
+state 7
+
+    (7) statement -> for_statement .
+
+    IF              reduce using rule 7 (statement -> for_statement .)
+    WHILE           reduce using rule 7 (statement -> for_statement .)
+    FOR             reduce using rule 7 (statement -> for_statement .)
+    LBRACE          reduce using rule 7 (statement -> for_statement .)
+    ID              reduce using rule 7 (statement -> for_statement .)
+    NUMBER          reduce using rule 7 (statement -> for_statement .)
+    $end            reduce using rule 7 (statement -> for_statement .)
+    RBRACE          reduce using rule 7 (statement -> for_statement .)
+    ELSE            reduce using rule 7 (statement -> for_statement .)
+
+
+state 8
+
+    (8) statement -> block .
+
+    IF              reduce using rule 8 (statement -> block .)
+    WHILE           reduce using rule 8 (statement -> block .)
+    FOR             reduce using rule 8 (statement -> block .)
+    LBRACE          reduce using rule 8 (statement -> block .)
+    ID              reduce using rule 8 (statement -> block .)
+    NUMBER          reduce using rule 8 (statement -> block .)
+    $end            reduce using rule 8 (statement -> block .)
+    RBRACE          reduce using rule 8 (statement -> block .)
+    ELSE            reduce using rule 8 (statement -> block .)
+
+
+state 9
+
+    (9) expression_statement -> expression . SEMICOLON
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    SEMICOLON       shift and go to state 17
+    PLUS            shift and go to state 18
+    MINUS           shift and go to state 19
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+
+state 10
+
+    (10) if_statement -> IF . LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> IF . LPAREN expression RPAREN statement
+
+    LPAREN          shift and go to state 22
+
+
+state 11
+
+    (12) while_statement -> WHILE . LPAREN expression RPAREN statement
+
+    LPAREN          shift and go to state 23
+
+
+state 12
+
+    (13) for_statement -> FOR . LPAREN expression_statement expression_statement expression RPAREN statement
+
+    LPAREN          shift and go to state 24
+
+
+state 13
+
+    (14) block -> LBRACE . statement_list RBRACE
+    (2) statement_list -> . statement
+    (3) statement_list -> . statement_list statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    statement_list                 shift and go to state 25
+    statement                      shift and go to state 3
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+    expression                     shift and go to state 9
+
+state 14
+
+    (15) expression -> ID . ASSIGN expression
+    (21) expression -> ID .
+
+    ASSIGN          shift and go to state 26
+    SEMICOLON       reduce using rule 21 (expression -> ID .)
+    PLUS            reduce using rule 21 (expression -> ID .)
+    MINUS           reduce using rule 21 (expression -> ID .)
+    TIMES           reduce using rule 21 (expression -> ID .)
+    DIVIDE          reduce using rule 21 (expression -> ID .)
+    RPAREN          reduce using rule 21 (expression -> ID .)
+
+
+state 15
+
+    (20) expression -> NUMBER .
+
+    SEMICOLON       reduce using rule 20 (expression -> NUMBER .)
+    PLUS            reduce using rule 20 (expression -> NUMBER .)
+    MINUS           reduce using rule 20 (expression -> NUMBER .)
+    TIMES           reduce using rule 20 (expression -> NUMBER .)
+    DIVIDE          reduce using rule 20 (expression -> NUMBER .)
+    RPAREN          reduce using rule 20 (expression -> NUMBER .)
+
+
+state 16
+
+    (3) statement_list -> statement_list statement .
+
+    IF              reduce using rule 3 (statement_list -> statement_list statement .)
+    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
+    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
+    LBRACE          reduce using rule 3 (statement_list -> statement_list statement .)
+    ID              reduce using rule 3 (statement_list -> statement_list statement .)
+    NUMBER          reduce using rule 3 (statement_list -> statement_list statement .)
+    $end            reduce using rule 3 (statement_list -> statement_list statement .)
+    RBRACE          reduce using rule 3 (statement_list -> statement_list statement .)
+
+
+state 17
+
+    (9) expression_statement -> expression SEMICOLON .
+
+    IF              reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    WHILE           reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    FOR             reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    LBRACE          reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    ID              reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    NUMBER          reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    $end            reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    RBRACE          reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+    ELSE            reduce using rule 9 (expression_statement -> expression SEMICOLON .)
+
+
+state 18
+
+    (16) expression -> expression PLUS . expression
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 27
+
+state 19
+
+    (17) expression -> expression MINUS . expression
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 28
+
+state 20
+
+    (18) expression -> expression TIMES . expression
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 29
+
+state 21
+
+    (19) expression -> expression DIVIDE . expression
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 30
+
+state 22
+
+    (10) if_statement -> IF LPAREN . expression RPAREN statement ELSE statement
+    (11) if_statement -> IF LPAREN . expression RPAREN statement
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 31
+
+state 23
+
+    (12) while_statement -> WHILE LPAREN . expression RPAREN statement
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 32
+
+state 24
+
+    (13) for_statement -> FOR LPAREN . expression_statement expression_statement expression RPAREN statement
+    (9) expression_statement -> . expression SEMICOLON
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression_statement           shift and go to state 33
+    expression                     shift and go to state 9
+
+state 25
+
+    (14) block -> LBRACE statement_list . RBRACE
+    (3) statement_list -> statement_list . statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    RBRACE          shift and go to state 34
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    statement                      shift and go to state 16
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+    expression                     shift and go to state 9
+
+state 26
+
+    (15) expression -> ID ASSIGN . expression
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 35
+
+state 27
+
+    (16) expression -> expression PLUS expression .
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    SEMICOLON       reduce using rule 16 (expression -> expression PLUS expression .)
+    PLUS            reduce using rule 16 (expression -> expression PLUS expression .)
+    MINUS           reduce using rule 16 (expression -> expression PLUS expression .)
+    RPAREN          reduce using rule 16 (expression -> expression PLUS expression .)
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+  ! TIMES           [ reduce using rule 16 (expression -> expression PLUS expression .) ]
+  ! DIVIDE          [ reduce using rule 16 (expression -> expression PLUS expression .) ]
+  ! PLUS            [ shift and go to state 18 ]
+  ! MINUS           [ shift and go to state 19 ]
+
+
+state 28
+
+    (17) expression -> expression MINUS expression .
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    SEMICOLON       reduce using rule 17 (expression -> expression MINUS expression .)
+    PLUS            reduce using rule 17 (expression -> expression MINUS expression .)
+    MINUS           reduce using rule 17 (expression -> expression MINUS expression .)
+    RPAREN          reduce using rule 17 (expression -> expression MINUS expression .)
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+  ! TIMES           [ reduce using rule 17 (expression -> expression MINUS expression .) ]
+  ! DIVIDE          [ reduce using rule 17 (expression -> expression MINUS expression .) ]
+  ! PLUS            [ shift and go to state 18 ]
+  ! MINUS           [ shift and go to state 19 ]
+
+
+state 29
+
+    (18) expression -> expression TIMES expression .
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    SEMICOLON       reduce using rule 18 (expression -> expression TIMES expression .)
+    PLUS            reduce using rule 18 (expression -> expression TIMES expression .)
+    MINUS           reduce using rule 18 (expression -> expression TIMES expression .)
+    TIMES           reduce using rule 18 (expression -> expression TIMES expression .)
+    DIVIDE          reduce using rule 18 (expression -> expression TIMES expression .)
+    RPAREN          reduce using rule 18 (expression -> expression TIMES expression .)
+
+  ! PLUS            [ shift and go to state 18 ]
+  ! MINUS           [ shift and go to state 19 ]
+  ! TIMES           [ shift and go to state 20 ]
+  ! DIVIDE          [ shift and go to state 21 ]
+
+
+state 30
+
+    (19) expression -> expression DIVIDE expression .
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    SEMICOLON       reduce using rule 19 (expression -> expression DIVIDE expression .)
+    PLUS            reduce using rule 19 (expression -> expression DIVIDE expression .)
+    MINUS           reduce using rule 19 (expression -> expression DIVIDE expression .)
+    TIMES           reduce using rule 19 (expression -> expression DIVIDE expression .)
+    DIVIDE          reduce using rule 19 (expression -> expression DIVIDE expression .)
+    RPAREN          reduce using rule 19 (expression -> expression DIVIDE expression .)
+
+  ! PLUS            [ shift and go to state 18 ]
+  ! MINUS           [ shift and go to state 19 ]
+  ! TIMES           [ shift and go to state 20 ]
+  ! DIVIDE          [ shift and go to state 21 ]
+
+
+state 31
+
+    (10) if_statement -> IF LPAREN expression . RPAREN statement ELSE statement
+    (11) if_statement -> IF LPAREN expression . RPAREN statement
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    RPAREN          shift and go to state 36
+    PLUS            shift and go to state 18
+    MINUS           shift and go to state 19
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+
+state 32
+
+    (12) while_statement -> WHILE LPAREN expression . RPAREN statement
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    RPAREN          shift and go to state 37
+    PLUS            shift and go to state 18
+    MINUS           shift and go to state 19
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+
+state 33
+
+    (13) for_statement -> FOR LPAREN expression_statement . expression_statement expression RPAREN statement
+    (9) expression_statement -> . expression SEMICOLON
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression_statement           shift and go to state 38
+    expression                     shift and go to state 9
+
+state 34
+
+    (14) block -> LBRACE statement_list RBRACE .
+
+    IF              reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    WHILE           reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    FOR             reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    LBRACE          reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    ID              reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    NUMBER          reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    $end            reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    RBRACE          reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+    ELSE            reduce using rule 14 (block -> LBRACE statement_list RBRACE .)
+
+
+state 35
+
+    (15) expression -> ID ASSIGN expression .
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+  ! shift/reduce conflict for PLUS resolved as shift
+  ! shift/reduce conflict for MINUS resolved as shift
+  ! shift/reduce conflict for TIMES resolved as shift
+  ! shift/reduce conflict for DIVIDE resolved as shift
+    SEMICOLON       reduce using rule 15 (expression -> ID ASSIGN expression .)
+    RPAREN          reduce using rule 15 (expression -> ID ASSIGN expression .)
+    PLUS            shift and go to state 18
+    MINUS           shift and go to state 19
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+  ! PLUS            [ reduce using rule 15 (expression -> ID ASSIGN expression .) ]
+  ! MINUS           [ reduce using rule 15 (expression -> ID ASSIGN expression .) ]
+  ! TIMES           [ reduce using rule 15 (expression -> ID ASSIGN expression .) ]
+  ! DIVIDE          [ reduce using rule 15 (expression -> ID ASSIGN expression .) ]
+
+
+state 36
+
+    (10) if_statement -> IF LPAREN expression RPAREN . statement ELSE statement
+    (11) if_statement -> IF LPAREN expression RPAREN . statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 9
+    statement                      shift and go to state 39
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+
+state 37
+
+    (12) while_statement -> WHILE LPAREN expression RPAREN . statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 9
+    statement                      shift and go to state 40
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+
+state 38
+
+    (13) for_statement -> FOR LPAREN expression_statement expression_statement . expression RPAREN statement
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 41
+
+state 39
+
+    (10) if_statement -> IF LPAREN expression RPAREN statement . ELSE statement
+    (11) if_statement -> IF LPAREN expression RPAREN statement .
+
+  ! shift/reduce conflict for ELSE resolved as shift
+    ELSE            shift and go to state 42
+    IF              reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    WHILE           reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    FOR             reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    LBRACE          reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    ID              reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    NUMBER          reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    $end            reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+    RBRACE          reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .)
+
+  ! ELSE            [ reduce using rule 11 (if_statement -> IF LPAREN expression RPAREN statement .) ]
+
+
+state 40
+
+    (12) while_statement -> WHILE LPAREN expression RPAREN statement .
+
+    IF              reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    WHILE           reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    FOR             reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    LBRACE          reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    ID              reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    NUMBER          reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    $end            reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    RBRACE          reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+    ELSE            reduce using rule 12 (while_statement -> WHILE LPAREN expression RPAREN statement .)
+
+
+state 41
+
+    (13) for_statement -> FOR LPAREN expression_statement expression_statement expression . RPAREN statement
+    (16) expression -> expression . PLUS expression
+    (17) expression -> expression . MINUS expression
+    (18) expression -> expression . TIMES expression
+    (19) expression -> expression . DIVIDE expression
+
+    RPAREN          shift and go to state 43
+    PLUS            shift and go to state 18
+    MINUS           shift and go to state 19
+    TIMES           shift and go to state 20
+    DIVIDE          shift and go to state 21
+
+
+state 42
+
+    (10) if_statement -> IF LPAREN expression RPAREN statement ELSE . statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression                     shift and go to state 9
+    statement                      shift and go to state 44
+    expression_statement           shift and go to state 4
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+
+state 43
+
+    (13) for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN . statement
+    (4) statement -> . expression_statement
+    (5) statement -> . if_statement
+    (6) statement -> . while_statement
+    (7) statement -> . for_statement
+    (8) statement -> . block
+    (9) expression_statement -> . expression SEMICOLON
+    (10) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
+    (11) if_statement -> . IF LPAREN expression RPAREN statement
+    (12) while_statement -> . WHILE LPAREN expression RPAREN statement
+    (13) for_statement -> . FOR LPAREN expression_statement expression_statement expression RPAREN statement
+    (14) block -> . LBRACE statement_list RBRACE
+    (15) expression -> . ID ASSIGN expression
+    (16) expression -> . expression PLUS expression
+    (17) expression -> . expression MINUS expression
+    (18) expression -> . expression TIMES expression
+    (19) expression -> . expression DIVIDE expression
+    (20) expression -> . NUMBER
+    (21) expression -> . ID
+
+    IF              shift and go to state 10
+    WHILE           shift and go to state 11
+    FOR             shift and go to state 12
+    LBRACE          shift and go to state 13
+    ID              shift and go to state 14
+    NUMBER          shift and go to state 15
+
+    expression_statement           shift and go to state 4
+    expression                     shift and go to state 9
+    statement                      shift and go to state 45
+    if_statement                   shift and go to state 5
+    while_statement                shift and go to state 6
+    for_statement                  shift and go to state 7
+    block                          shift and go to state 8
+
+state 44
+
+    (10) if_statement -> IF LPAREN expression RPAREN statement ELSE statement .
+
+    IF              reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    WHILE           reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    FOR             reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    LBRACE          reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    ID              reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    NUMBER          reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    $end            reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    RBRACE          reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+    ELSE            reduce using rule 10 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
+
+
+state 45
+
+    (13) for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .
+
+    IF              reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    WHILE           reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    FOR             reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    LBRACE          reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    ID              reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    NUMBER          reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    $end            reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    RBRACE          reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+    ELSE            reduce using rule 13 (for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement .)
+
+WARNING: 
+WARNING: Conflicts:
+WARNING: 
+WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
+WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
+WARNING: shift/reduce conflict for TIMES in state 35 resolved as shift
+WARNING: shift/reduce conflict for DIVIDE in state 35 resolved as shift
+WARNING: shift/reduce conflict for ELSE in state 39 resolved as shift
Index: analisador_sintatico.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/analisador_sintatico.py b/analisador_sintatico.py
new file mode 100644
--- /dev/null	(date 1732308397035)
+++ b/analisador_sintatico.py	(date 1732308397035)
@@ -0,0 +1,253 @@
+import ply.yacc as yacc
+from analisador_lexico import tokens, lexer
+import sys
+
+def parse_code(data):
+    parser = yacc.yacc(debug=True, debuglog=yacc.PlyLogger(sys.stderr))
+    result = parser.parse(data)
+    print("Árvore Sintática:")
+    print(result)
+    return result
+
+
+
+def p_program(p):
+    '''program : statement_list'''
+    p[0] = p[1]
+
+
+def p_comment(p):
+    '''statement : COMMENT'''
+    p[0] = ('comment', p[1])
+    pass
+
+
+def p_preprocessor_directive(p):
+    '''statement : HASH'''
+    p[0] = ('preprocessor_directive', p[1])
+    pass
+
+
+def p_statement(p):
+    '''statement : declaration
+                 | declaration_func
+                 | expression_statement
+                 | if_expression
+                 | for_expreression
+                 | while_expression
+                 | while_do_expression
+                 | return'''
+    p[0] = p[1]
+
+
+def p_statement_list(p):
+    '''statement_list : statement
+                      | statement_list statement'''
+    if len(p) == 2:
+        p[0] = [p[1]]
+    else:
+        p[0] = p[1] + [p[2]]
+
+
+def p_declaration(p): #arrumar vetor
+    '''declaration : TYPE ID SEMICOLON
+                   | TYPE ID ASSIGN expression SEMICOLON
+                   | TYPE ID ASSIGN funct
+                   | TYPE ID ASSIGN block
+                   | TYPE TIMES ID
+                   | TYPE vector
+                   | TYPE vector SEMICOLON
+                   | TYPE TIMES vector SEMICOLON
+                   | TYPE ID LBRACK RBRACK
+                   | TYPE ID LBRACK RBRACK ASSIGN expression SEMICOLON'''
+
+    if len(p) == 4: #caso type a;
+        p[0] = ('declaration', p[1], p[2])
+    elif len(p) == 5: # caso type *a;
+        p[0] = ('declaration', p[1], 'pointer', p[3])
+    elif len(p) == 6: # type a = expression
+        p[0] = ('declaration', p[1], p[2], p[4])
+    else:
+        p[0] = p[1]
+
+
+def p_expression_statement(p):
+    '''expression_statement : expression SEMICOLON
+                            | expression'''
+    p[0] = ('expr_stmt', p[1])
+
+
+def p_expression(p): #arrumar saida para pontei
+    '''expression : expression PLUS expression
+                  | expression MINUS expression
+                  | expression TIMES expression
+                  | expression DIVIDE expression
+                  | expression MOD expression
+                  | ID
+                  | NUMBER
+                  | TIMES ID
+                  | expression ASSIGN expression
+                  | STRING
+                  | LPAREN expression RPAREN
+                  | vector
+                  | expression PLUS_PLUS
+                  | expression MINUS_MINUS
+                  | expression PLUS_EQUAL
+                  | expression MINUS_EQUAL
+                  | block
+                  | expression COMMA expression
+                  | funct'''
+
+    if len(p) == 4:
+        p[0] =  (p[2], p[1], p[3])
+    else:
+        p[0] = p[1]
+
+def p_parameters(p):
+    '''parameters : TYPE ID
+                  | TYPE ID COMMA parameters
+                  | TYPE TIMES ID
+                  | TYPE TIMES ID COMMA parameters
+                  | TYPE ID LBRACK RBRACK
+                  | TYPE ID LBRACK RBRACK COMMA parameters
+                  | TYPE vector COMMA parameters
+                  | ID COMMA parameters
+                  | TIMES ID
+                  | TIMES ID COMMA parameters
+                  | ID LBRACK RBRACK
+                  | ID LBRACK RBRACK COMMA parameters
+                  | vector COMMA parameters
+                  | expression
+                  | parameters COMMA parameters'''
+
+    if len(p) == 3:
+        p[0] = ('parameter', p[1], p[2])  # Caso para TYPE ID
+    elif len(p) == 4:
+        p[0] = ('parameter', p[1], f"*{p[2]}")  # Caso para TYPE TIMES ID
+    elif len(p) == 6:
+        p[0] = ('parameter', p[1], p[2])  # Caso para TYPE ID COMMA parameters
+    elif len(p) == 7:
+        p[0] = ('parameter', p[1], f"*{p[2]}")  # Caso para TYPE TIMES ID COMMA parameters
+
+
+def p_declaration_func(p): #arrunar a saida
+    '''declaration_func : TYPE ID LPAREN parameters RPAREN block
+                        | TYPE ID LPAREN RPAREN block'''
+    if len(p) == 7:
+        p[0] = ('function_declaration', p[1], p[2], p[4], p[6])
+    else:
+        p[0] = ('function_declaration', p[1], p[2], [], p[5])
+
+def p_funct(p):
+    '''funct : ID LPAREN parameters RPAREN
+             | ID LPAREN RPAREN'''
+
+def p_if_expression(p): #arrumar saida
+    '''if_expression : IF LPAREN condicional RPAREN block
+                     | IF LPAREN condicional RPAREN block ELSE block'''
+    if len(p) == 6:
+        p[0] = ('if', p[3], p[5])  # ('if', condição, bloco_then)
+    else:
+        p[0] = ('if', p[3], p[5], p[7])  # ('if', condição, bloco_then, bloco_else)
+
+def p_condicional(p): #ARRUMAR SAIDA
+    '''condicional : ID operador_comp ID
+                   | ID operador_comp NUMBER
+                   | ID operador_comp vector
+                   | NUMBER operador_comp ID
+                   | NUMBER operador_comp NUMBER
+                   | NUMBER operador_comp vector
+                   | vector operador_comp ID
+                   | vector operador_comp NUMBER
+                   | vector operador_comp vector'''
+
+    p[0] = ('condicional', p[2], p[1], p[3])
+
+def p_vector(p):
+    '''vector : ID LBRACK expression RBRACK
+              | AMPERSAND vector'''
+
+    if len(p) == 5:
+        p[0] = ('vector_access', p[1], p[3])
+    else:
+        p[0] = ('reference', p[2])
+
+def p_pointer(p):
+    '''pointer : TIMES ID
+               | TIMES vector'''
+    p[0] = ('pointer', p[2])
+
+def p_block(p):
+    '''block : LBRACE statements RBRACE'''
+
+    p[0] = ('block', p[2])
+
+
+def p_operador_comp(p):
+      '''operadoror_comp : EQ
+                   | NE
+                   | GE
+                   | LE
+                   | GT
+                   | LT'''
+
+
+def p_for_expression(p): #ARRUMAR saida
+    '''for_expression : FOR LPAREN declaration ID operadoror_comp ID SEMICOLON ID PLUS_PLUS RPAREN block
+                        | FOR LPAREN declaration ID operadoror_comp ID SEMICOLON ID MINUS_MINUS RPAREN block
+                        | FOR LPAREN declaration ID operadoror_comp NUMBER SEMICOLON ID PLUS_PLUS RPAREN block
+                        | FOR LPAREN declaration ID operadoror_comp NUMBER SEMICOLON ID MINUS_MINUS RPAREN block'''
+    p[0] = ('for', p[3], p[4], p[6], p[8])
+
+
+def p_while_expression(p):
+    '''while_expression : WHILE LPAREN ID operadoror_comp ID RPAREN block
+                        | WHILE LPAREN ID operadoror_comp NUMBER RPAREN block
+                        | WHILE LPAREN NUMBER operadoror_comp ID RPAREN block
+                        | WHILE LPAREN NUMBER operadoror_comp NUMBER RPAREN block'''
+    p[0] = ('while', p[3], p[5])
+
+
+def p_while_do_expression(p):
+    '''while_do_expression : DO block WHILE LPAREN ID operadoror_comp ID RPAREN SEMICOLON
+                           | DO block WHILE LPAREN ID operadoror_comp NUMBER RPAREN SEMICOLON
+                           | DO block WHILE LPAREN NUMBER operadoror_comp ID RPAREN SEMICOLON
+                           | DO block WHILE LPAREN NUMBER operadoror_comp NUMBER RPAREN SEMICOLON'''
+    p[0] = ('do_while', p[2], p[5])
+    
+
+def p_return(p):
+    ''' return : RETURN expression SEMICOLON'''
+    p[0] = ('return', p[2])
+
+def print_tree(node, level=0):
+    indent = ' ' * level
+    if isinstance(node, tuple):
+        print(f'{indent}{node[0]}')
+        for child in node[1:]:
+            print_tree(child, level + 1)
+    elif isinstance(node, list):
+        for child in node:
+            print_tree(child, level + 1)
+    else:
+        print(f'{indent}{node}')
+
+def process_code(data, k):
+    lexer.input(data)
+    if k != 0:
+        while True:
+            tok = lexer.token()
+            if not tok:
+                break
+            print(f"Token: {tok.type}, Valor: {tok.value}, Linha: {tok.lineno}")
+
+    parsertab = yacc.yacc()
+    result = parsertab.parse(data)
+    print("Árvore Sintática:")
+    print_tree(result)
+
+def p_error(p):
+    if p:
+        print(f"Erro de sintaxe na linha {p.lineno}: {p.value}")
+    else:
+        print("Erro de sintaxe: final inesperado.")
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
--- /dev/null	(date 1732308697345)
+++ b/.idea/encodings.xml	(date 1732308697345)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="file://$PROJECT_DIR$/quick_sort.c" charset="UTF-16" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/parsetab.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/parsetab.py b/.idea/parsetab.py
new file mode 100644
--- /dev/null	(date 1731111492180)
+++ b/.idea/parsetab.py	(date 1731111492180)
@@ -0,0 +1,51 @@
+
+# parsetab.py
+# This file is automatically generated. Do not edit.
+# pylint: disable=W,C,R
+_tabversion = '3.10'
+
+_lr_method = 'LALR'
+
+_lr_signature = 'leftPLUSMINUSleftTIMESDIVIDEMODrightPOWnonassocLTGTLEGEEQNEAMPERSAND AND ASSIGN CHARACTER COLON COMMA COMMENT DIVIDE DOT DO_WHILE ELSE EQ FLOAT FOR GE GT HASH ID IF LBRACE LBRACK LE LPAREN LT MINUS MOD NE NUMBER OR PIPE PLUS POW RBRACE RBRACK RPAREN SEMICOLON STRING SWITCH TIMES TYPEDEF WHILEprogram : statement_liststatement_list : statement\n                      | statement_list statementstatement : expression_statement\n                 | if_statement\n                 | while_statement\n                 | for_statement\n                 | blockexpression_statement : expression SEMICOLONif_statement : IF LPAREN expression RPAREN statement ELSE statement\n                    | IF LPAREN expression RPAREN statementwhile_statement : WHILE LPAREN expression RPAREN statementfor_statement : FOR LPAREN expression_statement expression_statement expression RPAREN statementblock : LBRACE statement_list RBRACEexpression : ID ASSIGN expression\n                  | expression PLUS expression\n                  | expression MINUS expression\n                  | expression TIMES expression\n                  | expression DIVIDE expression\n                  | NUMBER\n                  | ID'
+    
+_lr_action_items = {'IF':([0,2,3,4,5,6,7,8,13,16,17,25,34,36,37,39,40,42,43,44,45,],[10,10,-2,-4,-5,-6,-7,-8,10,-3,-9,10,-14,10,10,-11,-12,10,10,-10,-13,]),'WHILE':([0,2,3,4,5,6,7,8,13,16,17,25,34,36,37,39,40,42,43,44,45,],[11,11,-2,-4,-5,-6,-7,-8,11,-3,-9,11,-14,11,11,-11,-12,11,11,-10,-13,]),'FOR':([0,2,3,4,5,6,7,8,13,16,17,25,34,36,37,39,40,42,43,44,45,],[12,12,-2,-4,-5,-6,-7,-8,12,-3,-9,12,-14,12,12,-11,-12,12,12,-10,-13,]),'LBRACE':([0,2,3,4,5,6,7,8,13,16,17,25,34,36,37,39,40,42,43,44,45,],[13,13,-2,-4,-5,-6,-7,-8,13,-3,-9,13,-14,13,13,-11,-12,13,13,-10,-13,]),'ID':([0,2,3,4,5,6,7,8,13,16,17,18,19,20,21,22,23,24,25,26,33,34,36,37,38,39,40,42,43,44,45,],[14,14,-2,-4,-5,-6,-7,-8,14,-3,-9,14,14,14,14,14,14,14,14,14,14,-14,14,14,14,-11,-12,14,14,-10,-13,]),'NUMBER':([0,2,3,4,5,6,7,8,13,16,17,18,19,20,21,22,23,24,25,26,33,34,36,37,38,39,40,42,43,44,45,],[15,15,-2,-4,-5,-6,-7,-8,15,-3,-9,15,15,15,15,15,15,15,15,15,15,-14,15,15,15,-11,-12,15,15,-10,-13,]),'$end':([1,2,3,4,5,6,7,8,16,17,34,39,40,44,45,],[0,-1,-2,-4,-5,-6,-7,-8,-3,-9,-14,-11,-12,-10,-13,]),'RBRACE':([3,4,5,6,7,8,16,17,25,34,39,40,44,45,],[-2,-4,-5,-6,-7,-8,-3,-9,34,-14,-11,-12,-10,-13,]),'ELSE':([4,5,6,7,8,17,34,39,40,44,45,],[-4,-5,-6,-7,-8,-9,-14,42,-12,-10,-13,]),'SEMICOLON':([9,14,15,27,28,29,30,35,],[17,-21,-20,-16,-17,-18,-19,-15,]),'PLUS':([9,14,15,27,28,29,30,31,32,35,41,],[18,-21,-20,-16,-17,-18,-19,18,18,18,18,]),'MINUS':([9,14,15,27,28,29,30,31,32,35,41,],[19,-21,-20,-16,-17,-18,-19,19,19,19,19,]),'TIMES':([9,14,15,27,28,29,30,31,32,35,41,],[20,-21,-20,20,20,-18,-19,20,20,20,20,]),'DIVIDE':([9,14,15,27,28,29,30,31,32,35,41,],[21,-21,-20,21,21,-18,-19,21,21,21,21,]),'LPAREN':([10,11,12,],[22,23,24,]),'ASSIGN':([14,],[26,]),'RPAREN':([14,15,27,28,29,30,31,32,35,41,],[-21,-20,-16,-17,-18,-19,36,37,-15,43,]),}
+
+_lr_action = {}
+for _k, _v in _lr_action_items.items():
+   for _x,_y in zip(_v[0],_v[1]):
+      if not _x in _lr_action:  _lr_action[_x] = {}
+      _lr_action[_x][_k] = _y
+del _lr_action_items
+
+_lr_goto_items = {'program':([0,],[1,]),'statement_list':([0,13,],[2,25,]),'statement':([0,2,13,25,36,37,42,43,],[3,16,3,16,39,40,44,45,]),'expression_statement':([0,2,13,24,25,33,36,37,42,43,],[4,4,4,33,4,38,4,4,4,4,]),'if_statement':([0,2,13,25,36,37,42,43,],[5,5,5,5,5,5,5,5,]),'while_statement':([0,2,13,25,36,37,42,43,],[6,6,6,6,6,6,6,6,]),'for_statement':([0,2,13,25,36,37,42,43,],[7,7,7,7,7,7,7,7,]),'block':([0,2,13,25,36,37,42,43,],[8,8,8,8,8,8,8,8,]),'expression':([0,2,13,18,19,20,21,22,23,24,25,26,33,36,37,38,42,43,],[9,9,9,27,28,29,30,31,32,9,9,35,9,9,9,41,9,9,]),}
+
+_lr_goto = {}
+for _k, _v in _lr_goto_items.items():
+   for _x, _y in zip(_v[0], _v[1]):
+       if not _x in _lr_goto: _lr_goto[_x] = {}
+       _lr_goto[_x][_k] = _y
+del _lr_goto_items
+_lr_productions = [
+  ("S' -> program","S'",1,None,None,None),
+  ('program -> statement_list','program',1,'p_program','analisador_sintatico.py',15),
+  ('statement_list -> statement','statement_list',1,'p_statement_list','analisador_sintatico.py',20),
+  ('statement_list -> statement_list statement','statement_list',2,'p_statement_list','analisador_sintatico.py',21),
+  ('statement -> expression_statement','statement',1,'p_statement','analisador_sintatico.py',29),
+  ('statement -> if_statement','statement',1,'p_statement','analisador_sintatico.py',30),
+  ('statement -> while_statement','statement',1,'p_statement','analisador_sintatico.py',31),
+  ('statement -> for_statement','statement',1,'p_statement','analisador_sintatico.py',32),
+  ('statement -> block','statement',1,'p_statement','analisador_sintatico.py',33),
+  ('expression_statement -> expression SEMICOLON','expression_statement',2,'p_expression_statement','analisador_sintatico.py',38),
+  ('if_statement -> IF LPAREN expression RPAREN statement ELSE statement','if_statement',7,'p_if_statement','analisador_sintatico.py',43),
+  ('if_statement -> IF LPAREN expression RPAREN statement','if_statement',5,'p_if_statement','analisador_sintatico.py',44),
+  ('while_statement -> WHILE LPAREN expression RPAREN statement','while_statement',5,'p_while_statement','analisador_sintatico.py',52),
+  ('for_statement -> FOR LPAREN expression_statement expression_statement expression RPAREN statement','for_statement',7,'p_for_statement','analisador_sintatico.py',57),
+  ('block -> LBRACE statement_list RBRACE','block',3,'p_block','analisador_sintatico.py',62),
+  ('expression -> ID ASSIGN expression','expression',3,'p_expression','analisador_sintatico.py',67),
+  ('expression -> expression PLUS expression','expression',3,'p_expression','analisador_sintatico.py',68),
+  ('expression -> expression MINUS expression','expression',3,'p_expression','analisador_sintatico.py',69),
+  ('expression -> expression TIMES expression','expression',3,'p_expression','analisador_sintatico.py',70),
+  ('expression -> expression DIVIDE expression','expression',3,'p_expression','analisador_sintatico.py',71),
+  ('expression -> NUMBER','expression',1,'p_expression','analisador_sintatico.py',72),
+  ('expression -> ID','expression',1,'p_expression','analisador_sintatico.py',73),
+]
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1727827732948)
+++ b/.idea/vcs.xml	(date 1727827732948)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
new file mode 100644
--- /dev/null	(date 1732309133953)
+++ b/main.py	(date 1732309133953)
@@ -0,0 +1,81 @@
+import subprocess
+import os
+
+def executar_analisadores(codigo_fonte):
+    # Salva o código no arquivo quick_sort.c
+    with open("quick_sort.c", "w") as file:
+        file.write(codigo_fonte)
+
+    # Chama o script do analisador léxico
+    print("Executando o analisador léxico...")
+    subprocess.run(["python", "analisador_lexico.py", "quick_sort.c"])
+
+    # Chama o script do analisador sintático
+    print("Executando o analisador sintático...")
+    subprocess.run(["python", "analisador_sintatico.py", "quick_sort.c"])
+
+if __name__ == "__main__":
+    codigo_fonte = """
+#include <stdio.h>
+
+// Função para trocar dois elementos
+void swap(int* a, int* b) {
+    int temp = *a;
+    *a = *b;
+    *b = temp;
+}
+
+// Particiona o array e retorna o índice do pivô
+int partition(int arr[], int low, int high) {
+    int pivot = arr[high]; // Escolhe o último elemento como pivô
+    int i = (low - 1); // Índice do menor elemento
+
+    for (int j = low; j < high; j++) {
+        // Se o elemento atual é menor ou igual ao pivô
+        if (arr[j] <= pivot) {
+            i++; // Incrementa o índice do menor elemento
+            swap(&arr[i], &arr[j]);
+        }
+    }
+    swap(&arr[i + 1], &arr[high]); // Coloca o pivô na posição correta
+    return (i + 1);
+}
+
+// Função principal do Quicksort
+void quicksort(int arr[], int low, int high) {
+    if (low < high) {
+        // Particiona o array e obtém o índice do pivô
+        int pi = partition(arr, low, high);
+
+        // Ordena recursivamente as duas metades
+        quicksort(arr, low, pi - 1);
+        quicksort(arr, pi + 1, high);
+    }
+}
+
+// Função para imprimir o array
+void printArray(int arr[], int size) {
+    for (int i = 0; i < size; i++) {
+        printf("%d ", arr[i]);
+    }
+    printf("\\n");
+}
+
+// Função principal
+int main() {
+    int arr[] = {10, 7, 8, 9, 1, 5};
+    int n = sizeof(arr) / sizeof(arr[0]);
+
+    printf("Array original: ");
+    printArray(arr, n);
+
+    quicksort(arr, 0, n - 1);
+
+    printf("Array ordenado: ");
+    printArray(arr, n);
+    return 0;
+}
+"""
+
+    # Chama a função para executar os analisadores
+    executar_analisadores(codigo_fonte)
\ No newline at end of file
Index: .idea/Projeto-Integrador-III.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Projeto-Integrador-III.iml b/.idea/Projeto-Integrador-III.iml
new file mode 100644
--- /dev/null	(date 1727827732934)
+++ b/.idea/Projeto-Integrador-III.iml	(date 1727827732934)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
--- /dev/null	(date 1727827727996)
+++ b/.idea/.gitignore	(date 1727827727996)
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1727827913196)
+++ b/.idea/misc.xml	(date 1727827913196)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Black">
+    <option name="sdkName" value="Python 3.11" />
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_22" default="true" project-jdk-name="Python 3.11" project-jdk-type="Python SDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1727827732938)
+++ b/.idea/modules.xml	(date 1727827732938)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/Projeto-Integrador-III.iml" filepath="$PROJECT_DIR$/.idea/Projeto-Integrador-III.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
